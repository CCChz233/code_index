{"summary": "We need to summarize the functionality of the code snippet. The code is from tools/bench-asyncio-write.py. It imports asyncio, atexit, math, os, signal, typing List, Tuple. It defines a constant PORT = 8888. Then server = os.fork() (forks a process). Then defines writes = [ (\"b''.join\", write_joined_list), (\"bytearray\", write_joined_bytearray), (\"multiple writes\", write_separately), ] So writes is a list of tuples mapping a description to a function (presumably defined elsewhere). Then bodies = ( [], [10 * 2**0], [10 * 2**7], [10 * 2**17], [10 * 2**27], [50 * 2**27], [1 * 2**0 for _ in range(10)], [1 * 2**7 for _ in range(10)], [1 * 2**17 for _ in range(10)], [1 * 2**27 for _ in range(10)], [10 * 2**27 for _ in range(5)], ) So bodies is a tuple of lists of integers representing sizes. Then jobs = [_job(j) for j in bodies] So jobs is a list of tuples (job_title, body) where body is a list of bytes objects. Then loop = asyncio.get_event_loop() results = loop.run_until_complete(main(loop)). So main is presumably defined elsewhere. Then defines a helper function _job(j: List[int]) -> Tuple[str, List[bytes]]: # Always start with a 256B headers chunk body = [b\"0\" * s for s in [256] + list(j)] job_title = f\"{fm_size(sum(j))} / {len(j)}\" return (job_title, body). So _job creates a list of bytes: first a 256-byte header, then for each size in j, a bytes object of that size filled with \"0\". job_title is a formatted string showing total size (sum of j) formatted by fm_size (presumably a function that formats size) and number of chunks (len(j)). So overall, this script appears to be a benchmark for asyncio write performance. It forks a server process (maybe to listen on a port). It defines different write strategies (join list, bytearray, multiple writes). It defines various payload bodies of different sizes and chunk counts. It creates jobs (title + body).", "prompt_id": "28ad819ea97a795ed2ae85e64d974c5c", "created_at": "2026-02-04T20:33:48.408952"}