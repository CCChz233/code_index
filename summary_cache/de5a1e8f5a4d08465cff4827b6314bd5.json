{"summary": "- The code defines a function `IterableModel` that dynamically creates a new Pydantic model class for handling multiple tasks of a given subtask class.\n- The function takes a subtask class (a subclass of `BaseModel`), an optional name, and an optional description.\n- It generates a new class name based on the subtask class name, prefixed with `Iterable`.\n- The new class inherits from `OpenAISchema` and `IterableBase` (presumably a base class for iterable iterable). \n- The new class includes a `tasks` field that is a list of the subtask class instances.\n- The new\nWe need to produce a summary of the functionality of the code, focusing on business logic, inputs, outputs, in Chinese (or Chinese/English). Must start directly with the summary content, no \"This code does...\" or \"Here is...\". So start with something like \"\u529f\u80fd\u6982\u8ff0\uff1a...\". Provide business logic, inputs, outputs. Use Chinese. Let's read the code.\n\nThe code is in instructor/dsl/iterable.py. It imports typing, collections.abc, pydantic, instructor.function_calls.OpenAISchema, instructor.mode.Mode, instructor.utils.extract_json_from_stream, extract_json_from_stream_async.\n\nDefines a function IterableModel(subtask_class: type[BaseModel], name: Optional[str] = None, description: Optional[str] = None) -> type[BaseModel].\n\nDocstring explains dynamic creation of an IterableModel OpenAISchema to segment multiple tasks given a base class. It creates a class that can be used to create a toolkit for a specific task, names and descriptions automatically generated but can be overridden.\n\nUsage example: define a User BaseModel, then MultiUser = IterableModel(User). The result is a class MultiUser(OpenAISchema, MultiTaskBase) with tasks: List[User] field, and a classmethod from_streaming_response that parses streaming response from OpenAI and yields a User object for each task.\n\nParameters: subtask_class (Type[OpenAISchema]), name optional, description optional. Returns: schema (OpenAISchema) new class.\n\nImplementation: task_name = subtask_class.__name__ if name is None else name. name = f\"Iterable{task_name}\". list_tasks = (list[subtask_class], Field(...)). base_models = cast(tuple[type[BaseModel], ...], (OpenAISchema, IterableBase)). new_cls = create_model(name, tasks=list_tasks, __base__=base_models). new", "prompt_id": "28ad819ea97a795ed2ae85e64d974c5c", "created_at": "2026-02-04T20:58:40.485808"}